// prisma/schema.prisma
// NOTE: This file fixes missing opposite relation fields required by Prisma.
// It is compatible with existing DB structure (no new columns), so it should not require a new migration.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  EMPLOYEE
}

enum BillingType {
  FIXED
  HOURLY
  MONTHLY_RETAINER
}

enum Cadence {
  ONE_OFF
  RECURRING_MONTHLY
}

enum ProjectStatus {
  ACTIVE
  PAUSED
  DONE
}

enum TimeEntryStatus {
  SUBMITTED
  APPROVED
  REJECTED
}

enum BonusType {
  ONE_OFF
  MONTHLY
}

enum ConversationType {
  DIRECT
  GROUP
}

enum AvailabilityStatus {
  AVAILABLE
  VACATION
  SICK
}

model User {
  id                String   @id @default(cuid())
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  role              Role     @default(EMPLOYEE)
  name              String
  email             String   @unique
  passwordHash      String

  hourlyRateDefault Int?     // grosze (np. 8000 = 80,00 PLN/h)

  availability      AvailabilityStatus @default(AVAILABLE)

  // Relations
  assignments       Assignment[]
  timeEntries       TimeEntry[]        @relation("TimeEntryAuthor")
  bonuses           Bonus[]
  goals             EmployeeGoal[]
  auditLogs         AuditLog[]
  notifications     Notification[]

  // --- FIXES REQUIRED BY PRISMA VALIDATION ---
  // Opposite side for TimeEntry.reviewedBy
  reviewedTimeEntries TimeEntry[] @relation("ReviewedBy")
  // Opposite side for ConversationParticipant.user
  conversationParticipants ConversationParticipant[]
  // ------------------------------------------

  sentMessages      Message[] @relation("MessageSender")
  messageReads      MessageRead[]
}

model Client {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name      String
  note      String?

  projects  Project[]

  @@index([name])
}

model Project {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clientId  String
  client    Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)

  name      String
  tags      String[] @default([])

  billingType BillingType
  cadence     Cadence
  status      ProjectStatus @default(ACTIVE)

  // Revenue settings (grosze)
  monthlyRetainerAmount Int?
  fixedClientPrice      Int?

  assignments Assignment[]
  timeEntries  TimeEntry[]

  @@index([clientId])
  @@index([status])
  @@index([billingType])
}

model Assignment {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  projectId String
  project   Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  hourlyRateOverride  Int?  // grosze
  fixedPayoutAmount   Int?  // grosze (dla FIXED — wynagrodzenie za wykonanie)
  activeFrom          DateTime?
  activeTo            DateTime?

  @@unique([userId, projectId])
  @@index([projectId])
  @@index([userId])
}

model TimeEntry {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId    String
  user      User     @relation("TimeEntryAuthor", fields: [userId], references: [id], onDelete: Cascade)

  projectId String
  project   Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  date      DateTime // (YYYY-MM-DD) — zapisuj jako Date, ale w Prisma to DateTime
  hours     Decimal  @db.Decimal(5,2)
  note      String?
  status    TimeEntryStatus @default(SUBMITTED)

  reviewedById String?
  reviewedBy   User?    @relation("ReviewedBy", fields: [reviewedById], references: [id])
  reviewedAt   DateTime?

  @@index([userId, date])
  @@index([projectId, date])
  @@index([status])
  @@index([reviewedById])
}

model Bonus {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  amount    Int      // grosze
  type      BonusType
  month     String?  // "YYYY-MM" dla MONTHLY
  note      String?

  @@index([userId])
  @@index([type, month])
}

model Conversation {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  type      ConversationType
  name      String?

  participants ConversationParticipant[]
  messages      Message[]

  @@index([type])
}

model ConversationParticipant {
  id             String   @id @default(cuid())
  createdAt      DateTime @default(now())

  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  userId         String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  lastReadAt     DateTime?

  @@unique([conversationId, userId])
  @@index([userId])
  @@index([conversationId])
}

model Message {
  id             String   @id @default(cuid())
  createdAt      DateTime @default(now())

  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  senderId       String
  sender         User     @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)

  body           String

  reads          MessageRead[]

  @@index([conversationId, createdAt])
  @@index([senderId, createdAt])
}

model MessageRead {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  messageId String
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)

  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([userId])
}

// --- Extra features: audit log, goals, notifications ---

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  APPROVE
  REJECT
  LOGIN
  LOGOUT
  OTHER
}

model AuditLog {
  id        String     @id @default(cuid())
  createdAt DateTime   @default(now())

  actorId   String?
  actor     User?      @relation(fields: [actorId], references: [id], onDelete: SetNull)

  action    AuditAction
  entity    String
  entityId  String?
  meta      Json?

  @@index([createdAt])
  @@index([actorId])
  @@index([entity, entityId])
}

model EmployeeGoal {
  id            String    @id @default(cuid())
  userId        String
  month         String    // "YYYY-MM"
  targetHours   Decimal   @db.Decimal(6, 2)
  targetRevenue Decimal?  @db.Decimal(12, 2)
  bonusAmount   Decimal?  @db.Decimal(12, 2)
  note          String?
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, month], name: "userId_month")
  @@index([userId])
}


enum NotificationType {
  MISSING_HOURS_REMINDER
  GENERIC
}

model Notification {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  readAt    DateTime?

  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  type      NotificationType
  title     String
  body      String?

  @@index([userId, readAt])
  @@index([type])
}
