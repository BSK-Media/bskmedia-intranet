// prisma/schema.prisma
// Patched: NotificationType enum now includes `MISSING_HOURS` (used by reminders API),
// while keeping existing values for compatibility.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  EMPLOYEE
}

enum BillingType {
  FIXED
  HOURLY
  MONTHLY_RETAINER
}

enum Cadence {
  ONE_OFF
  RECURRING_MONTHLY
}

enum ProjectStatus {
  ACTIVE
  PAUSED
  DONE
}

enum TimeEntryStatus {
  SUBMITTED
  APPROVED
  REJECTED
}

enum BonusType {
  ONE_OFF
  MONTHLY
}

enum ConversationType {
  DIRECT
  GROUP
}

enum AvailabilityStatus {
  AVAILABLE
  VACATION
  SICK
}

model User {
  id                String   @id @default(cuid())
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  role              Role     @default(EMPLOYEE)
  name              String
  email             String   @unique
  passwordHash      String

  hourlyRateDefault Int?

  availability      AvailabilityStatus @default(AVAILABLE)

  assignments       Assignment[]
  timeEntries       TimeEntry[]        @relation("TimeEntryAuthor")
  bonuses           Bonus[]
  goals             EmployeeGoal[]
  auditLogs         AuditLog[]
  notifications     Notification[]

  reviewedTimeEntries      TimeEntry[] @relation("ReviewedBy")
  conversationParticipants ConversationParticipant[]

  sentMessages      Message[] @relation("MessageSender")
  messageReads      MessageRead[]
}

model Client {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name      String
  note      String?

  // Optional contact details
  contactName  String?
  contactEmail String?
  contactPhone String?

  projects  Project[]

  @@index([name])
}

model Project {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clientId  String
  client    Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)

  name      String
  tags      String[] @default([])

  billingType BillingType
  hourlyClientRate      Int? // stawka klienta za godzinę (np. w groszach)
  cadence     Cadence
  status      ProjectStatus @default(ACTIVE)

  // Revenue settings (grosze)
  monthlyRetainerAmount Int?
  fixedClientPrice      Int?

  // Set when project becomes DONE
  completedAt DateTime?

  // Okres kontraktu (dla projektów cyklicznych)
  contractStart DateTime @default(now())
  contractEnd   DateTime?

  // Deadline projektu (ważne dla rozliczeń jednorazowych)
  deadlineAt    DateTime?

  assignments Assignment[]
  timeEntries  TimeEntry[]
  bonuses      Bonus[]

  @@index([clientId])
  @@index([status])
  @@index([billingType])
  @@index([completedAt])
}

model Assignment {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  projectId String
  project   Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  hourlyRateOverride  Int?
  fixedPayoutAmount   Int?
  activeFrom          DateTime?
  activeTo            DateTime?

  @@unique([userId, projectId])
  @@index([projectId])
  @@index([userId])
}

model TimeEntry {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId    String
  user      User     @relation("TimeEntryAuthor", fields: [userId], references: [id], onDelete: Cascade)

  projectId String
  project   Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  date      DateTime
  hours     Decimal  @db.Decimal(5,2)
  note      String?
  status    TimeEntryStatus @default(SUBMITTED)

  reviewedById String?
  reviewedBy   User?    @relation("ReviewedBy", fields: [reviewedById], references: [id])
  reviewedAt   DateTime?

  @@index([userId, date])
  @@index([projectId, date])
  @@index([status])
  @@index([reviewedById])
}

model Bonus {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Optional: bonus can be assigned to a specific project.
  // Keeping it nullable to preserve backward compatibility with older data.
  projectId String?
  project   Project? @relation(fields: [projectId], references: [id], onDelete: SetNull)

  amount    Int
  type      BonusType
  month     String?
  note      String?

  @@index([userId])
  @@index([projectId])
  @@index([type, month])
}

model Conversation {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  type      ConversationType
  name      String?

  participants ConversationParticipant[]
  messages      Message[]

  @@index([type])
}

model ConversationParticipant {
  id             String   @id @default(cuid())
  createdAt      DateTime @default(now())

  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  userId         String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  lastReadAt     DateTime?

  @@unique([conversationId, userId])
  @@index([userId])
  @@index([conversationId])
}

model Message {
  id             String   @id @default(cuid())
  createdAt      DateTime @default(now())

  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  senderId       String
  sender         User     @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)

  body           String

  reads          MessageRead[]

  @@index([conversationId, createdAt])
  @@index([senderId, createdAt])
}

model MessageRead {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  messageId String
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)

  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([userId])
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  APPROVE
  REJECT
  LOGIN
  LOGOUT
  OTHER
  UPSERT
}

model AuditLog {
  id        String     @id @default(cuid())
  createdAt DateTime   @default(now())

  actorId   String?
  actor     User?      @relation(fields: [actorId], references: [id], onDelete: SetNull)

  action    AuditAction
  entity    String
  entityId  String?
  meta      Json?

  @@index([createdAt])
  @@index([actorId])
  @@index([entity, entityId])
}

model EmployeeGoal {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  month         String

  targetHours   Decimal  @db.Decimal(6,2)
  targetRevenue Int?
  bonusAmount   Int?
  note          String?

  @@unique([userId, month])
  @@index([month])
  @@index([createdAt])
}

enum NotificationType {
  // New value required by app/api/admin/reminders/generate
  MISSING_HOURS

  // Existing values kept for compatibility
  MISSING_HOURS_REMINDER
  GENERIC
}

model Notification {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  readAt    DateTime?

  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  type      NotificationType
  title     String
  body      String?

  @@index([userId, readAt])
  @@index([type])
}
